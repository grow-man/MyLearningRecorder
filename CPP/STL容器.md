# STRING

### 1. std::string是basic_string<char>的特化版本，string是basic_string<char>的别名,C++ 标准库还提供了其他字符类型的字符串类，例如 std::wstring 用于 wchar_t 类型的字符串。

### 2. 一般来讲，在string非空时begin()指向容器的首元素，end()指向'\0'。

### 3. string的内存布局大致如下：
![image](https://github.com/grow-man/MyLearningRecorder/assets/52662997/ff9904ee-0c1f-4240-9ec2-00528d627cd2)


### 4. string实现了重载的[]运算符，可以像数组一样访问string的元素。

### 5. string和C字符串的区别：
#### 5.1 string支持拼接操作(重载了运算符'+'、'+=')，C字符串不支持。
#### 5.2 string支持查找(find(),rfind())，C字符串不支持。

# VECTOR 向量(动态数组)

    使用场景:当你不知道该使用什么容器时，缺省使用它。但是由于在触发扩容时会重新分配内存，以及对原始数据进行拷贝会大大降低效率  
    所以在使用时应尽量在开始创建容器时设置一个合适的大小。

### 1. vector是C++ STL中的一个数据结构，它是一个能够存放任意类型的动态数组，并且能够根据需要自动增长容量。

### 2. vector的内存布局大致如下：
### 3. 由于vector底层由动态数组实现，所以它具有以下特性：
#### 3.1 数组中存放元素的指针指向一段连续的内存空间，所以能够使用data()成员函数获取这段空间的起始地址。
#### 3.2 在vector中在尾部插入删除具有较高效率，因为不需要移动元素。
#### 3.3 由于vector的元素是连续存放的，所以支持随机访问，同样也支持使用下标访问元素。

### 4. vector容器的大小
#### 4.1 size()返回的是当前vector中元素的个数。
#### 4.2 capacity()返回的是当前vector底层数组能够容纳的元素大小。
#### 4.3 max_size()表示在系统中vector最大上限，它一般受系统和编译器的限制。
#### 4.4 reserve()和resize()都是用来设置当前vector的容量大小。一般reserve()用于预设容量大小。resize()设置容量大小和初始化元素，若当前大小大于预设值则减小容器否则扩大并已初始值初始化。

# deque 双端队列
    1、主要使用场景：当你需要同时在头/尾 插入/删除元素时，使用deque  
    2、deque的内存布局大致如下：

    2、deque的特性：
    如果只从头、尾两个位置对 deque 进行增删操作的话，容器里的对象永远不需要移动。
    容器里的元素只是部分连续的（因而没法提供 data 成员函数）。
    由于元素的存储大部分仍然连续，它的遍历性能是比较高的。
    由于每一段存储大小相等，deque 支持使用下标访问容器元素，大致相当于 index[i /
    chunk_size][i % chunk_size]，也保持高效。

# list 双向链表
    1、主要使用场景：当你需要频繁地在容器任意位置添加或删除元素时，使用list。
    2、list的内存布局大致如下：
    3、list的特性：
    由于list的元素不是连续存储的，所以不支持随机访问，但是支持通过迭代器访问元素。基于同样的原因不支持data操作。
    list的元素是链式存储，增删效率较高，但是查找效率较低。
    对于如下算法：merge remove remove_if reverse sort unique list提供成员函数作为替代。

# stack 栈 以及 queue 队列
    1、使用场景：栈的特性是先进后出，所以在某些需要优先处理最新到达的数据时，使用栈比较方便。-- 例如项目中对ATS数据的处理。
    而队列的特性是先进先出，所以当需要处理最先到达的数据时，使用队列比较方便。-- 例如DTP平台的消息队列。
    2、stack和queue的底层实现都是deque，所以stack和queue的特性都是类似的。
    由于deque支持动态增长，所有stack和queue同样支持动态增长。
    

