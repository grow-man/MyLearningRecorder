# 使用for(int i=0;i<vInfo.size();i++) 的循环，遍历vInfo中的元素时删除vInfo中的元素，导致崩溃。

    原因是遍历容器并在遍历过程中删除其中的元素可能导致迭代器失效，从而导致崩溃。请使用迭代器删除元素，而不是使用索引删除元素。

`for (auto it = vInfo.begin(); it != vInfo.end(); ) {`
    `if (/* 满足删除条件 */) {`
        `it = vInfo.erase(it);  // 注意：删除元素会返回下一个有效迭代器`
   ` } else {`
       ` ++it;  // 移动到下一个元素`
   ` }`
`}`

# 在结构中包含容器时使用`memste(&stData, 0, sizeof(stData))` 导致崩溃。

* 使用visual studio调试时报错如下：
  ![image](https://github.com/grow-man/MyLearningRecorder/assets/52662997/28f98e32-db87-4ef5-b62f-655427842c8f)


    这是因为 memset 是一个用于按字节清零内存的底层函数，它不了解容器内部的结构和动态分配的内存。当你使用 memset 来清零一个包含容器的结构体时，会破坏容器的内部数据结构，导致后续的操作出现问题。
    
# 容器的内部数据结构包括但不限于以下内容：

1. **元素存储**：容器存储其元素的方式取决于容器类型。例如，`std::vector` 使用连续的内存块，`std::list` 使用双向链表，`std::map` 使用红黑树，`std::unordered_map` 使用哈希表等。

2. **迭代器**：容器通常提供迭代器，用于遍历容器中的元素。迭代器是指向容器内部元素的指针或对象，它们知道如何遍历容器中的元素，包括指向下一个元素的方法。迭代器在容器的内部数据结构中起着重要作用。

3. **大小和容量**：容器内部通常会跟踪容器的大小（元素的数量）和容量（可以容纳的元素数量）等信息。这些信息对于容器的管理和性能优化非常重要。

4. **分配器**：容器通常使用分配器来管理内存分配和释放。分配器负责为容器的元素分配内存，并在不再需要时释放内存。不同的容器可以使用不同的分配器，具体取决于容器的类型和配置。

5. **锁和同步机制**：在多线程环境中，某些容器（如 `std::vector` 或 `std::list`）可能包含用于同步访问的锁或其他同步机制。这些机制用于确保多个线程可以安全地访问容器。

6. **其他内部状态**：具体容器类型可能还包含其他内部状态，以支持其特定的操作和性能优化。



