# recv 函数反复返回0   

`recv()` 函数是在网络编程中常用的函数之一，用于接收数据。它的原型如下：

```c
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

- **参数说明**：
  - `sockfd`：指定要接收数据的套接字文件描述符。
  - `buf`：接收数据的缓冲区，即数据将被存储到这个缓冲区中。
  - `len`：缓冲区的长度，即指定能够接收的最大字节数。
  - `flags`：一组标志，用于控制接收操作的行为，通常设置为0。

- **返回值**：`recv()` 函数的返回值表示实际接收到的数据字节数，如果返回-1，则表示出现了错误，返回0表示对端已经关闭连接。

```linux man page
RETURN VALUE
       These calls return the number of bytes received, or -1 if an error occurred.
       In the event of an error, errno is set to indicate the error.
       The return value will be 0 when  the  peer  has  per‐
       formed an orderly shutdown.
```

**现象**  
![image](https://github.com/grow-man/MyLearningRecorder/assets/52662997/aa811524-d2a9-48dc-8409-4e259182c276)  
   
如上图,软件recv反复触发peer disconnect,但是抓包并没有FIN报文   


- **问题代码如下**：
```
UINT32 RecvPAMsg()
{
    INT32   iRecvLen;
    UINT32  ulTotalRecvLen = 0;
    UINT32  ulRecvLen;

    if (g_ulCurrPAMsgLen < sizeof(PA_MSG_HDR_T))
    {
        ulRecvLen = sizeof(PA_MSG_HDR_T) - g_ulCurrPAMsgLen;
        ulTotalRecvLen = sizeof(PA_MSG_HDR_T);
    }
    else
    {
        PA_MSG_HDR_T *pstHdr = (PA_MSG_HDR_T*)g_aucPAMsg;

        ulTotalRecvLen = sizeof(PA_MSG_HDR_T) + ntohs(pstHdr->usMsgLen);
        ulRecvLen = ulTotalRecvLen - g_ulCurrPAMsgLen; /// 异常时此处ulRecvLen被设为0

        if (ulTotalRecvLen > MAX_MSG_BUF_SIZE)
        {
            GosLog(LOG_ERROR, "recvLen is too big : %u", ulTotalRecvLen);
            GosLog(LOG_ERROR, "pstHdr->usMsgLen is %#x", pstHdr->usMsgLen);

            return RECV_MSG_INVALID;
        }
    }

    if (ulRecvLen == 0)
    {
        GosLog(LOG_ERROR, "invalid recv len");
        return RECV_MSG_INVALID;
    }

    iRecvLen = recv(g_stPATCPClientSocket, (CHAR*)g_aucPAMsg + g_ulCurrPAMsgLen, ulRecvLen, 0);
    if (iRecvLen < 0)
    {
        GosLog(LOG_ERROR, "RecvPAMsg: recv Pa failed, %s", gos_get_socket_err());
        return RECV_FAIL;
    }
    else if (iRecvLen == 0)
    {
        GosLog(LOG_ERROR, "RecvPAMsg: recv PA failed, disconnect by peer");
        return RECV_FAIL;
    }

    if (g_ulCurrPAMsgLen <= sizeof(PA_MSG_HDR_T)) /// 异常位置
    {
        PA_MSG_HDR_T *pstHdr = (PA_MSG_HDR_T*)g_aucPAMsg;

        g_ulCurrPAMsgLen += iRecvLen;
        if (g_ulCurrPAMsgLen < sizeof(PA_MSG_HDR_T)) 
        {
            return RECV_NEEDMORE;
        }

        UINT16    usMsgMagic = NTOHS(pstHdr->usMsgMagic);

        if (usMsgMagic != PIS_MSG_MAGIC)
        {
            GosLog(LOG_ERROR, "RecvPAMsg: recv PA failed, magic(%04X) is invalid", pstHdr->usMsgMagic);

            PrintMsg(pstHdr, g_ulCurrPAMsgLen);
            memset(g_aucPAMsg, 0, sizeof(g_aucPAMsg));
            return RECV_MSG_INVALID;
        }

        ulRecvLen = ntohs(pstHdr->usMsgLen);
        if (ulRecvLen == 0)     // 没有消息体
        {
            g_ulCurrPAMsgLen = 0;
            return RECV_PA_SUCC;
        }

        return RECV_NEEDMORE;
    }
    else
    {
        g_ulCurrPAMsgLen += iRecvLen;
        if (g_ulCurrPAMsgLen == ulTotalRecvLen)
        {
            g_ulCurrPAMsgLen = 0;
            return RECV_PA_SUCC;
        }

        GosLog(LOG_WARN, "RecvPAMsg: curr msg len is %u, total len should be %u", 
                                    g_ulCurrPAMsgLen, ulTotalRecvLen);

        return RECV_NEEDMORE;
    }
}
```
上述代码预期为先接收制定报文头长度(6个字节)的数据，然后根据报文头中data数据长度字段接收剩余部分数据.由于在异常位置多了一个 `==`判断，导致在完整接收第一个数据包之后并不能正确返回`RECV_PA_SUCC`,  
而是返回`RECV_NEEDMORE`. 由于测试时协议数据包的完整长度为12字节(头6字节+数据6字节)，进入下一轮NEEDMORE时`ulRecvLen`被设置为0，导致recv返回值为0，程序反复打印`RecvPAMsg: recv PA failed, disconnect by peer`.  

**教训** 
在recv之前需要对待接收数据长度参数做检查  
